## java虚拟机
### 2 java内存区域与内存溢出异常
#### 2.2 运行时数据区域
```
1. 程序计数器：当前程序所执行的字节码的行号指示器。各线程直接计数器互不影响，独立存储。线程私有的。如果执行的是Native方法，则计数器为空。这是唯一一个在java虚拟机规范中没有任何outOfMemaryError的情况的区域。

2. java虚拟机栈：也是线程私有的，它的生命周期与线程相同。描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。（StackOverflowError、OutOfMemoryError异常）

3. 本地方法栈：与虚拟机栈类似，只不过是本地方法服务。（StackOverflowError、OutOfMemoryError异常）

4. java堆：是虚拟机中管理的内存中最大的一块。被所哟线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一目的是存放对象实例。可以分为：新生代和老年代。采用分代收集算法。OutOfMemoryError异常

5. 方法区：和java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。也被称为永久代。官方有放弃永久代改为采用Native Memory来实现方法区的规划。在jdk7中已经把原本放在永久代的字符串常量池移出。OutOfMemoryError异常

6. 运行时常量池：是方法区的一部分。在类加载后放入运行时常量。具备动态性，运行期间可以将新的常量放入池中。OutOfMemoryError异常

7. 直接内存：并不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的内存区域。可能会OutOfMemoryError异常。jdk1.4，加入NIO类引入了一种基于通道channel和缓冲区Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免在Java堆和Native堆中来回复制数据。
```

