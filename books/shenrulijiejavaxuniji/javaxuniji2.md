## java虚拟机
### 2 java内存区域与内存溢出异常
#### 2.2 运行时数据区域
>
1. 程序计数器：当前程序所执行的字节码的行号指示器。各线程直接计数器互不影响，独立存储。线程私有的。如果执行的是Native方法，则计数器为空。这是唯一一个在java虚拟机规范中没有任何outOfMemaryError的情况的区域。
>
2. java虚拟机栈：也是线程私有的，它的生命周期与线程相同。描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。（StackOverflowError、OutOfMemoryError异常）
>
3. 本地方法栈：与虚拟机栈类似，只不过是本地方法服务。（StackOverflowError、OutOfMemoryError异常）
>
4. java堆：是虚拟机中管理的内存中最大的一块。被所哟线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一目的是存放对象实例。可以分为：新生代和老年代。采用分代收集算法。OutOfMemoryError异常
>
5. 方法区：和java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。也被称为永久代。官方有放弃永久代改为采用Native Memory来实现方法区的规划。在jdk7中已经把原本放在永久代的字符串常量池移出。OutOfMemoryError异常
>
6. 运行时常量池：是方法区的一部分。在类加载后放入运行时常量。具备动态性，运行期间可以将新的常量放入池中。OutOfMemoryError异常
>
7. 直接内存：并不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的内存区域。可能会OutOfMemoryError异常。jdk1.4，加入NIO类引入了一种基于通道channel和缓冲区Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免在Java堆和Native堆中来回复制数据。

#### hotspot虚拟机对象探秘

>
1. 对象的创建：虚拟机遇到new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有则执行相应的类加载过程。
1.1 创建过程：
		1. 在常量池检查是否有符号引用，是否已被加载、解析和初始化。
		2. 为新生对象分配内存
		3. 分配的内存空间初始化为零值，保证对象的实例字段可以不赋值就直接使用。
		4. 对对象进行必要的设置，是哪个类的实例，如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。
		5. 执行init方法

>
2. 对象的内存布局，对象在内存中布局可分为3块区域：对象头、实例数据和对齐填充。
	1. 虚拟机对象头包括两部分信息，第一部分用于存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳等，这部分数据长度在32位和64位的虚拟机中分别为32bit和64bit;第二部分是类型指针，即对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例。
	2. 实例数据是对象存储的真正有效信息，在代码中定义的各种类型的字段内容。无论是在父类中继承下来的，还是在子类中定义的，都需要记录起来。

>
3.对象的访问定位
建立对象是为了使用对象，我们的java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象具体位置，所以对象访问方式取决于虚拟机实现。主流的访问方式有使用句柄和直接指针 

#### 实战：OutOfMemoryError异常
>
1. java堆溢出 -Xms -Xmx
不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在数据量到达最大堆的容量限制后就会产生内存溢出异常。
通过参数设置在出现异常时Dump出当前内存转储快照以便时候进行分析。先分清是内存泄露还是内存溢出。
java.lang.OutOfMemoryError: java heap space

>
2. 虚拟机栈和本地方法栈溢出 -Xss
在hotspot中不区分虚拟机栈和本地方法栈。在java虚拟机规范中描述两种异常StackOverflowError和OutOfMemoryError异常
java.lang.StackOverflowError
java.lang.OutOfMemoryError: unable to create new native thread


>
3. 方法区和运行时常量池溢出 -XX:PermSize 和 -XX:MaxPermSize
jdk1.6 java.lang.OutOfMemoryError:PermGen space
jdk1.6 String.intern方法会把首次遇到的字符串实例复制到永久代中，返回的是永久代这个字符串实例的引用。
jdk1.7 strin.intern方法不会再复制实例，只是在常量池中记录首次出现的实例引用。
方法区用于存放class相关信息，如类名，访问修饰符、常量池、字段描述、方法描述等。


>
4. 本机直接内存溢出 -XX

### 垃圾收集器与内存分配策略

- 哪些内存需要回收
- 什么时候回收
- 如何回收

#### 对象已死么？
    
>
1. 引用计数算法
很难解决对象之间的互相循环引用的问题。

2. 可达性分析算法
通过GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。
GC Roots对象包括以下几种：
- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

3. 再谈引用

4. 生存还是死亡

5. 回收方法区

#### 垃圾收集算法

>
1. 标记清除算法
先标记后统一回收，最基础算法。效率问题和空间问题。

2. 复制算法
解决效率问题，内存分为大小相等两块，当一块内存使用完了，将还存活的对象复制到另一块上面，然后清理使用的内存。

3. 标记整理算法
和标记清除算法一样，但后续步骤是让所有存活对象都移向一端，润喉直接清理掉边界以外的内存。

4. 分代收集算法
当前商业虚拟机都采用分代算法，吧内存分为不同的代，根据不同的代采用不同的算法。 

#### HotSpot算法的实现

>
1. 枚举根节点
类加载完成的时候，使用OopMap的数据结构，把对象什么偏移量上是什么类型的数据计算出来。在JIT编译工程也会记录栈和寄存器哪些位置是引用。

2. 安全点


3. 安全区域

#### 垃圾收集器
